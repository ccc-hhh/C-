# C-
一、阶段一
1.1 阶段一任务
项目一阶段一的任务是完成网络协议系的模型层次设计，搭建雏形并测试，并且个人完成套接字编程。这里对网络协议系的模型层次设计做汇报。
1.2 模型层次设计
1.2.1 结构设计
通过查阅相关资料，我们明确了最小网元应由应用层、网络层、物理层这三层组成，并且在后面的交换机、路由器的设计中，我们把数据链路层与网络层合并为一层。
最小网元模型：
 
图表 1
1.2.1 功能介绍
（1）应用层：
应用层主要是与用户进行直接交互的层次，传输的数据是基于用户认知范围的字符，主要体现在各种运行在操作系统上的应用软件或者命令行等等。应用层可以将字符型数据传至网络层，网络层也可以将字符型数据传给应用层。
（2）网络层：
网络层架在物理层和应用层之间，主要负责数据的转码。当应用层向下传数据时，网络层会将应用层的数据进行编码，形成能在物理层传输的比特流，然后在送给物理层。同理，当物理层向上传送比特流数据时，网络层会将比特流每八位进行译码，形成字符串数据传送给应用层。
（3）物理层：
物理层负责传输比特流信息，在物理层上可以定义多条信道，连接不同的信宿和信源或者相同的信宿和信源。在部分体现在网络层设置过程中会涉及到物理层模块的连接，在那个部分可以同时在一个网卡上挂若干个物理层模块。
1.3 阶段一测试
我们利用老师的参考例程对该模型进行了测试。
测试结果：
 
图表 2
 
图表 3
二、阶段二
2.1 阶段二任务
完成帧同步，差错控制，流量控制设计。完成应用数据产生、处理、控制——可以手动录入数据，用于单独跟踪测试，也可自动生成信源数据，测试系统可靠性和功能，收端对数据进行检查和显示。
2.2 设计思路
本次最小网元设计是基于上次套接字程序的再设计，整体框架由上次写的套接字代码和连接物理层的代码构成。在此基础上，添加了成帧函数、CRC校验码生成函数和差错检测函数，流量控制的实现体现在主函数中。
发送端应用层用于生成数据并向发送端网络层发送数据。发送端网络层接收到应用层的数据，对数据进行成帧处理，并把帧发送到物理层。物理层接收到数据，在传输过程中会产生扰码或误码，扰码与帧会一起传给接收端的网络层。数据传给接收端网络层后，网络层中的差错检测函数会对帧进行识别，并利用CRC校验码校验原始数据，若数据无误则把提取出来的原始数据传给接收端应用层，若数据错误，则向应用层发送错误代码，同时也向发送端发送一个反馈，若数据无误则发送全1内容的帧，若数据错误则发送全0内容的帧。发送端的网络层接收到反馈后会判断反馈信息的内容，然后向应用层发送信息，让应用层判断是否重传。
这样整个数据发送及重新传输的流程就可以实现了。
2.5 实现的功能
我们在阶段二中实现了重传、发送文字、发送图片等功能。

2.4 主要的函数设计
2.4.1 成帧函数
详细分析物理信道传送的比特数据内容时，我首先向物理层发送了一些数据，可以明显的观察到我发送的数据和物理层本身传输的同步时钟信号（形如“010101”的比特流）是混合在一起的，所以我们无法从物理层提取到自己真正想收的信号。于是我需要对我们传输的数据内容做出处理：封装成帧。
封装的帧形式如下：
 
无论用户在应用层选择的数据形式是怎样的，我们都把数据转换为二进制编码，再加入数据序号发送给网络层，让网络层对其计算校验码及封装成帧。
2.4.2 CRC校验码生成函数
物理层信道会有随机的误码产生，这对误码的修正做出了要求。本次设计采用的是CRC校验码，利用八位数据产生一个八位二进制的CRC校验码后放在帧内数据的后面。
为了简化代码，我们采用了查表的方式帮助实现。
2.4.3 差错校验及帧提取函数
本次的网元设计中，我们把帧的提取函数和差错校验函数放在了一个函数里，这样可以让代码更简单，数据提取及校验更方便。
对于帧的提取，我们采用了直接的提取方式，即在一个if语句中直接把帧头帧尾识别出来，这样的方式看似暴力，但是不会出现错把与帧头一样的原始数据识别为帧头或帧尾的情况。在if语句里把原始数据及CRC校验码分别提取出来，然后对原始数据生成一个新的CRC校验码，两个校验码对比，则可以判断数据有没有错误。
由于通过信道传输而来的数据是不可信的，若有错误产生，我们不知道到底是八位数据发生了误码，还是八位CRC校验码发生了误码，所以无法进行纠错，对于这种情况，我们选择重传数据。
2.4.4 文字编码与解码函数
要想传输文字，则必须对文字编码，简便起见，我们规定只能传输英文。我们利用ASCII码对英文进行转换，再把ASCII码值转换为八位二进制数。
文字的解码则与编码过程相反。
例：
 
图表 4
2.4.5 图片编码与解码函数
我们采用base64方法对图片进行编码。进行base64编码后会生成一串字符串，然后再把每个字符转换为八位二进制数，即实现了对图片的编码。
对图片的解码过程与编码过程相反。
例：
将要传输的图片：（15×14）
 
图表 5
base64编码后产生的字符串：共1984个字符。
转换为二进制后的比特流：共15872比特（部分）

2.4 应用层及网络层结构设计
2.4.1 发送接收机制
1、发送端的网元：
（1）应用层：应用层有两种产生数据的方式，一是产生随机的八位二进制数据并将其发送到网络层，二是将用户输入的文字编码成二进制码流并拆分成八位二进制数再将其发送到网络层。
（2）网络层：网络层接收数据后先生成CRC校验码，再封装成帧，并将帧发往物理层。
 
图表 6
2、接收端的网元：
（1）网络层：网络层接收到物理层发来的数据后，对数据进行帧的提取，再进行八位数据的提取，并生成新的CRC校验码，与原校验码对比，判断数据是否发生错误。若无误则发往应用层，若有误则发送提示信息。
（2）应用层：应用层接收到网络层发来的数据后，首先判断这个数据是不是错误信息，若不是，则打印出八位数据，或把文字还原并打印；若是错误信息，则打印错误提示。
 
2.4.2 反馈机制
1、接收端的网元：
接收端发送反馈主要是依靠网络层，网络层对接收的帧校验后，无论数据是错误还是正确，都给发送端反馈一个信息。若数据错误，我们定义01111110 00000000 00000000 01111110为错误信息并发送，若数据正确，定义01111110 11111111 11111111 01111110为正确信息并发送。
2、发送端的网元
发送端接收反馈并判断的也是在网络层。网络层接收反馈后根据帧中的信息判断发给接收端的数据在接收端是否无误。若为错误提示信息，则发送一个错误提示信息给应用层，让应用层重传。若为正确提示信息，则发送一个正确提示信息给应用层，让应用层打印数据及接收发送成功。
关于反馈信息也可能存在误码的解决办法：我们编写了一个用来提取反馈帧及帧中信息的函数，并设计了一个弹性的机制。
反馈帧的第一种误码的情况：帧头或帧尾误码。帧头或帧尾误码，则接收不到这个反馈，这种情况即为超时，网络层认为超时即是对方没能接收到正确的信息，所以发送端会重传一次。
反馈帧的第二种误码的情况：帧中的16位信息产生误码。对于这种情况，我们设计了一个弹性机制，即若16位信息中1的位数大于12位，则认为是正确提示的反馈信息，若小于12位则认为是错误提示的反馈信息，则需要重传。
2.4.3 重传机制
重传主要是在发送端的应用层实现。
应用层接收到网络层发来的错误提示的反馈信息后，保存本次的传输数据，并把重传判断参数调为1（重传判断参数为1则为需要重传，为0则不需要），这样在下一个传输循环中，发送的数据就会和上一次的一样，即实现了重传。
 
图表 7
2.4.4 超时处理机制
利用select机制可以实现超时处理，select函数中timeout结构体定义的等待时间，若规定时间内没有接收到数据或没有数据需要发送，则判断为超时，此时，发送超时提醒，并跳出循环或终止程序。
2.5 阶段二测试
2.5.1 测试的分类
我们对网元进行了四类测试，第一次是与其他小组合作的测试，在两台计算机上把两个小组的网元连接，我们组作为数据发送端，他组为数据接收端；其他的测试是自己设计的两个网元连接测试，一类是随机产生数据，一类是用户输入文字，还有一类是传输图片。
2.5.2 与他组合作的的测试
因为两台电脑的IP地址不同，所以我们查询了各自电脑的IPv4地址，并填在物理层模拟软件上，就实现了两台电脑间不两个物理层模拟软件的连接。因为我们与对方的重传机制不一样，所以这里没有重传。
结果如图：数据发送端：
 
图表 8
数据接收端：
 
图表 9
本次测试共发送10个数据，全部成功接收并提取出原数据。
2.5.3 随机数据的测试
发送端应用层随机产生数据：
发送端：左为应用层，右为网络层
 
图表 10
 
图表 11
接收端：左为应用层，右为网络层。
 
图表 12
从图片中的数据可见，第1、2次发生了误码，而且是反馈信息的误码，发送端重传了两次。
2.5.3 传输文字的测试
测试1：在发送端应用层输入“hello”，让其发送。
发送端：左为应用层，右为网络层。
 
图表 13
接收端：左为应用层，右为网络层。
 
图表 14
接收端把“hello”打印的下来。
测试2：在发送端应用层输入“hello，world”，让其发送。
发送端网络层： 
 
图表 15
接收端应用层：
 
图表 16
2.5.4 传输图片的测试
待传输的图片：（15×14）
 
图表 17
接收端：
 
图表 18
数据对比：
 
图表 19
解码后的图片：
 
图表 20
三、阶段三
3.1 阶段三任务
完成交换接口排队模型设计——多接入的寻址设计，完成二层交换模型设计。（需结合单元四中讨论的二层交换技术）。
3.2 设计思路
本次设计依靠于配置文件中的“ne 5 三个网元三层 连成环 交换机模型”。所以本次的设计是三个网元连成环状，每一个网元都是一个交换机，都能完成成帧、差错控制、寻址、转发的功能。在整个模型中，可以实现点对点及广播。
3.3 结构设计
3.3.1 网元结构
在OSI模型中，交换机本应在数据链路层，但我们出于简化网元的考虑，没有设计数据链路层，而是把交换机的功能放到我们设计的网元的网络层。这样网元仍是三层结构：应用层、网络层（数据链路层）、物理层。
 
图表 21
3.3.2 交换机模型结构设计
在我们的交换机模型中，三个网元连成环，构成环状拓扑，规定以逆时针方向发送数据。每个网元都是交换机，都可以发送、接收和转发数据，也就是说，每个网元都是一样的。
 
图表 22
如果网元1作为数据的发送端，则它向端口号为11100的物理层发出数据，网元2从端口号为12100的物理层接收数据，在网元2的网络层（数据链路层）判断是转发还是自己接收还是既转发又接收（广播）。如果是转发，则网元2从端口号为12101的物理层发出数据，网元3从端口号为13101的物理层接收数据。如果是网元2接收了数据，则网元3无需做任何操作。
3.3.3 帧结构
由于要实现寻址功能，所以我们在帧里加入用于识别目的端口号的4位比特。编号为：实体号+设备号，再将编号转换为4位二进制数，再加入源端口号。
 
3.4阶段三测试
3.4.1 点对点
数据发送端（网元1）：
 
图表 23
数据的转发与接收（网元2与网元3）：
 
图表 24
数据接收（网元3）：
 
图表 25
3.4.2 广播
数据发送端（网元1）：
 
图表 26
数据接收端（网元2与网元3）（网元2也要转发数据）：
网元2：
 
图表 27
网元3：
 
图表 28









四、阶段四
4.1 阶段四任务
完成路由器设计，完成混合组网设计。
4.2 设计思路
1、路由器：路由器设计依靠于配置文件中的“ne 9 三个网元 四层 连成环 路由器模型”。所以本次的设计是三个网元连成环状，每一个网元都是一个路由器。
2、混合组网：混合组网设计依靠于配置文件中的“ne 12 六个网元 混和组网，1个交换机 3个路由器连成环“。所以混合组网的设计中有一个交换机三个路由器及两个主机。
由于混合组网中包含了路由器环路，所以在阶段四中，我们把路由器的设计与混合组网的设计结合了起来，一同完成。 
4.3 结构设计
4.3.1 混合组网结构
网元1为交换机，网元2、3、4为路由器，网元5、6为主机。
 
图表 29
4.3.2 网元结构
出于简化的考虑，我们没有增加链路层，而是把链路层与网络层结合为一层，其结构与阶段三相同。
4.4 路由器设计
在最小网元设计中，由于网络拓扑简单，路由器与交换机实现的功能十分相似。在本次的设计中，我们设计的是静态路由，并且配置了静态路由表。
静态路由表的配置示例：
 
图表 30
分别为网元2、3、4配置路由表：

4.5 阶段四测试
4.5.1 点对点
数据发送端：网元5
 
图表 31
数据转发：
网元1：
 
图表 32
网元2：
 
图表 33
数据接收端：网元3
 
图表 34
4.5.2 广播
数据发送端：网元5
 
图表 35
数据接收及转发：
网元1：
 
图表 36
网元2：
 
图表 37
网元3：
 
图表 38
网元4：
 
图表 39
五、总结
此次最小网元设计实验，是一次很考验学生编程能力的实验。通过这次实验，我们的C语言编程能力进一步增强，并且掌握了C语言网络编程的大部分知识，收获颇丰。
在这次实验中，我们通过停止等待流量控制完成了网元间信息的传输，包括传输文字和图片，完成了交换机和路由器的模拟，完成了包含交换机和路由器的混合组网的设计，实现了项目一的要求。
但是我们的工作仍有很多不足，停止等待流量控制不能高效地传输数据，路由器为静态路由，不能根据网络的变化而变化等。
总的来说，我们在完成项目一的过程中投入了许多，也收获了许多，是一次很好的项目经历。
六、小组成员
陈希昱：负责项目一，完成各结构设计及主体程序的编写；10分
许宏涛：参与各个结构设计的讨论，参与完成竞争性实验及编写部分函数；10分
盛麟翔：参与各个结构设计的讨论，负责竞争性实验及编写部分函数；10分
刘泽军：参与各个结构设计的讨论，参与完成竞争性实验；7分


